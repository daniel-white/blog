{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blog/2020/06/async-code-the-changing-abstractions",
    "result": {"data":{"post":{"slug":"/blog/2020/06/async-code-the-changing-abstractions","title":"Async code: the changing abstractions","date":"2020-06-28","tags":[{"name":"async","slug":"async"},{"name":"code","slug":"code"}],"description":"My understanding of the changing abstractions for asynchronous code","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Async code: the changing abstractions\",\n  \"date\": \"2020-06-28\",\n  \"description\": \"My understanding of the changing abstractions for asynchronous code\",\n  \"slug\": \"blog/2020/06/async-code-the-changing-abstractions\",\n  \"tags\": [\"async\", \"code\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I've been mulling over how \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Moore%27s_law\"\n  }, \"Moore's law\"), \" has\\naparently slowed on the x86 architecture and how the rise of strong language support for\\nasynchronous patterns has happened about the same time.\"), mdx(\"p\", null, \"Have these asynchronous patterns come to help squeak more performance out of dwindling\\nhardware returns on investment? I would say there's some merit to that, but our machines\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"have always been asynchronous\"), \" from the original hardware designs. Operating systems\\nand libraries have previously taken a large share of the burden to enable developers\\nvery tight procedural code, at the cost of hurting the machine.\"), mdx(\"p\", null, \"I don't advertise to be a hardware or operating system expert here, these are just my\\nobservations that could be wrong.\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/daniel-white/daniel-white.github.io/issues/new\"\n  }, \"Please send any comments to my way via GitHub\"), \".\"), mdx(\"h3\", null, \"Asynchronicity in hardware\"), mdx(\"p\", null, \"Hardware I/O by its nature has always been asynchronous:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Insert disk 1 into floppy drive A:\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Press any key to continue...\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mouse button clicked\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read file into memory from disk\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"etc.\")), mdx(\"p\", null, \"When the hardware wanted to inform the software running, it would signal interupts on the CPU.\\nI'm not sure of the complete details, but it was enough for primitive software to let the CPU\\ncompletely interupt what it was doing to handle the event. These events weren't CPU bound and\\nwere \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"asynchronous\"), \" to the software running.\"), mdx(\"h3\", null, \"Cooperative multitasking \", \"&\", \" preemtive operating systems\"), mdx(\"p\", null, \"Operating systems in the early 1990s weren't the multitasking behemoths that our modern\\noperating systems are today. Many were implemented with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cooperative multitasking\"), \".\"), mdx(\"p\", null, \"Essentially cooperative multitasking put the onus on the application developers to\\nplay fair with other applications. Applications would have to be written in such a way to\\nyield control back to the operating system. There were no separate threads to worry about.\"), mdx(\"p\", null, \"For instance, a call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OpenFile\"), \" would return control to the operating system.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"OFSTRUCT reOpenBuff;\\nHFILE hFile = OpenFile(\\\"myFile.txt\\\", &reOpenBuff, OF_READ);\\n// use the file\\n\")), mdx(\"p\", null, \"Eventually once the hardware informs the operating system (and other layers)\\nthat the file is in memory, the operating then can reschedule the application.\\nTo the application, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OpenFile\"), \" call would simply block any other execution.\"), mdx(\"p\", null, \"The mid-1990s brought preemptive multitasking operating systems to the main stream.\\nThe operating system could control individual processes time on the CPU. At the time,\\nmultiple CPUs weren't a thing. Thread APIs were exposed to get the illusion of\\nconcurrency in a single process - but the I/O calls still blocked threads and\\nthreads are a constrained resource.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I've been mulling over how  Moore's law  has\naparently slowed on the x86 architecture and how the rise of strong language support forâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/blog/2020/06/async-code-the-changing-abstractions","formatString":"YYYY-MM-DD"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}